#!/usr/bin/env python
print("importing libraries")
import rosbag
import cv_bridge

import sm
from sm import PlotCollection
import aslam_cv as acv
import aslam_cameras_april as acv_april
import aslam_cv_backend as acvb
import kalibr_common as kc
import kalibr_camera_calibration as kcc
import kalibr_rs_camera_calibration as rscc

import cv2
import os
import numpy as np
import pylab as pl
import argparse
import sys
import random
import signal
import time

np.set_printoptions(suppress=True)

def __initBagDataset(bagfile, topic, from_to, perform_syncrhronization):
    print("\tDataset:          {0}".format(bagfile))
    print("\tTopic:            {0}".format(topic))
    reader = kc.BagImageDatasetReader(bagfile, topic, bag_from_to=from_to,
                                      perform_synchronization=perform_syncrhronization)
    print("\tNumber of images: {0}".format(reader.numImages()))
    return reader

#available models
cameraModels = {
    # rolling shutter
    'pinhole-radtan-rs': acvb.DistortedPinholeRs,
    'pinhole-equi-rs':   acvb.EquidistantPinholeRs,
    'pinhole-fov-rs':    acvb.FovPinholeRs,
    'omni-radtan-rs':    acvb.DistortedOmniRs,
    # global shutter
    'pinhole-radtan':    acvb.DistortedPinhole,
    'pinhole-equi':      acvb.EquidistantPinhole,
    'pinhole-fov':       acvb.FovPinhole,
    'omni-radtan':       acvb.DistortedOmni,
}

def __signal_exit(signal, frame):
    sm.logWarn("Shutdown requested! (CTRL+C)")
    sys.exit(2)

def __parseArgs():
    class KalibrArgParser(argparse.ArgumentParser):
        def error(self, message):
            self.print_help()
            sm.logError('%s' % message)
            sys.exit(2)
        def format_help(self):
            formatter = self._get_formatter()
            formatter.add_text(self.description)
            formatter.add_usage(self.usage, self._actions,
                                self._mutually_exclusive_groups)
            for action_group in self._action_groups:
                formatter.start_section(action_group.title)
                formatter.add_text(action_group.description)
                formatter.add_arguments(action_group._group_actions)
                formatter.end_section()
            formatter.add_text(self.epilog)
            return formatter.format_help()

    usage = """
    Example usage to calibrate a camera system with a single rolling shutter camera using an aprilgrid.

    cam: pinhole model with radial-tangential distortion and rolling shutter for a single camera

    %(prog)s --model pinhole-radtan-rs --target aprilgrid.yaml \\
              --bag MYROSBAG.bag --topic /cam0/image_raw \\
              --feature-variance 1 --frame-rate 20

    example aprilgrid.yaml:
        target_type: 'aprilgrid'
        tagCols: 6
        tagRows: 6
        tagSize: 0.088  #m
        tagSpacing: 0.3 #as a fraction of tagSize"""

    parser = KalibrArgParser(description='Calibrate the intrinsics of a single rolling shutter camera.', usage=usage)
    parser.add_argument('--model', dest='model', help='The camera model to estimate. '
                        'Currently supported models are {0}, where the suffix \'-rs\' identifies rolling shutter models.'.format(', '.join(cameraModels.keys())), required=True)

    groupSource = parser.add_argument_group('Data source')
    groupSource.add_argument('--bag', dest='bagfile', help='The bag file with the data.')
    groupSource.add_argument('--topic', dest='topic', help='The image topic.', required=True)
    groupSource.add_argument('--bag-from-to', metavar='bag_from_to', type=float, nargs=2, help='Use the bag data starting from up to this time [s].')

    groupTarget = parser.add_argument_group('Calibration target configuration')
    groupTarget.add_argument('--target', dest='targetYaml', help='Calibration target configuration as yaml file.', required=True)
    groupTarget.add_argument('--feature-variance', dest='featureVariance', type=float, help='Estimated variance of the feature detector.', required=True)

    groupOpt = parser.add_argument_group('Optimization options')
    groupOpt.add_argument('--max-iter', type=int, default=30, dest='max_iter', help='Max. iterations (default: %(default)s).', required=False)
    groupOpt.add_argument('--recover-covariance', action='store_true', dest='recover_cov',
                          help='Recover the covariance of the design variables.', required=False)
    groupOpt.add_argument('--lock-intrinsics', action='store_true', dest='lock_intrinsics', help='Disable the intrinsics calibration', required=False)      
    groupOpt.add_argument('--lock-distortion', action='store_true', dest='lock_distortion', help='Disable the distortion calibration', required=False)
    groupOpt.add_argument('--time-calibration', action='store_true', dest='time_calibration', help='Enable time shift cam_imu calibration', required=False)
    groupOpt.add_argument('--timeoffset-padding', type=float, default=0.5, dest='timeoffset_padding',
                          help='Maximum range in which the timeoffset may change during estimation [s] '
                               '(default: %(default)s)', required=False)
    groupOpt.add_argument('--timeoffset-pattern', type=float, default=80e-3, dest='timeoffset_pattern',
                          help='A time offset to pad the blocks generated in the hessian/jacobian to ensure'
                               ' a constant symbolic representation of the batch estimation problem, even when a change'
                               ' in the shutter timing shifts the capture time to another spline segment.')

    groupCam = parser.add_argument_group('Camera system configuration')
    groupCam.add_argument('--cams', dest='chain_yaml', help=('Camera system configuration as yaml file.\n'
        'If camera yaml is provided, then values from the yaml will be used for initializing the camera'), required=False)
    # TODO(jhuai): Currently the optimization with IMU data does not converge at all.
    groupImu = parser.add_argument_group('IMU configuration')
    groupImu.add_argument('--imu', dest='imu_yaml', help=('Yaml holding the IMU noise parameters.'
            ' Thanks to the ConfigReader, no hierarchy should be used in the yaml.'))
    groupImu.add_argument('--imu-model', dest='imu_model', help= \
            ('The IMU models to estimate. Currently supported are \'calibrated\','
             ' \'scale-misalignment\' and \'scale-misalignment-size-effect\'.'), default="calibrated")
    groupImu.add_argument('--constant_bias', action='store_true', help="bias is constant or time-varying")
    groupImu.add_argument('--perform_synchronization', action='store_true',
                           help=('Perform a clock synchronization according to '
                                '\'Clock synchronization algorithms for network measurements\' '
                                 'by Zhang et al. (2002).'))

    outputSettings = parser.add_argument_group('Output options')
    outputSettings.add_argument('--verbose', action='store_true', dest='verbose', help='Enable (really) verbose output (disables plots).')
    outputSettings.add_argument('--show-extraction', action='store_true', dest='showextraction', help='Show the calibration target extraction. (disables plots).')
    outputSettings.add_argument('--save-sample-poses', action='store_true', dest='saveSamplePoses',
                                help='Save sampled poses from the optimized B-splines?')
    parser.add_argument('--reproject-frame-index', dest='reprojectFrameIndex', type=int, default=0,
                        help='Zero-based index of the frame for reprojection in the frames used by calibration.')

    # print help if no argument is specified
    if len(sys.argv)==1:
        parser.print_help()
        sys.exit(2)

    # Parse the argument list
    try:
        parsed = parser.parse_args()
    except:
        sys.exit(2)

    # there is an issue with the gtk plot widget, so we cant plot if we have opencv windows open...
    # --> disable the plots in these special situations
    if parsed.showextraction or parsed.verbose:
        parsed.dontShowReport = True

    return parsed

# perform corner extraction from bagfile
# returns the observations
def __extractObservations(cameraGeometry, verbose=False):
    if cameraGeometry.dataset.hasFeatureAssociations():
        return cameraGeometry.dataset.getFeatureAssociations()
    else:
        # extract the targets
        multithreading = False #not verbose
        observations = kc.extractCornersFromDataset(
            cameraGeometry.dataset,
            cameraGeometry.ctarget.detector,
            multithreading=multithreading,
            # transformation estimation will fail with rs cameras and significant distortions
            noTransformation=True
        )
        return observations

def main():
    parsed = __parseArgs()

    # logging modes
    if parsed.verbose:
        sm.setLoggingLevel(sm.LoggingLevel.Debug)
    else:
        sm.setLoggingLevel(sm.LoggingLevel.Info)

    # register signal handler
    signal.signal(signal.SIGINT, __signal_exit)

    ######
    ## load bagfile and extract targets:
    targetConfig = kc.CalibrationTargetParameters(parsed.targetYaml)
    if parsed.bagfile.endswith('.bag'):
        dataset = __initBagDataset(parsed.bagfile, parsed.topic, parsed.bag_from_to, parsed.perform_synchronization)
    else:
        dataset = kc.VimapCsvReader(parsed.bagfile, parsed.topic, parsed.bag_from_to, False)

    #create camera
    cameraModel = cameraModels[parsed.model]
    cameraGeometry = kcc.CameraGeometry(cameraModel, targetConfig, dataset, verbose=(parsed.verbose or parsed.showextraction))

    # extract observations
    # Because of python2, perf_counter is not available. 
    # Because of Unix, we choose to use time.time() instead of time.clock().
    tic = time.time()
    observations = __extractObservations(cameraGeometry,(parsed.verbose or parsed.showextraction))
    toc = time.time()
    extract_time = toc - tic

    # Calibration Configuration
    config = rscc.RsCalibratorConfiguration()
    config.inverseFeatureCovariance = 1.0/parsed.featureVariance
    config.maxNumberOfIterations = parsed.max_iter
    config.timeOffsetConstantSparsityPattern = parsed.timeoffset_pattern
    config.timeOffsetPadding = parsed.timeoffset_padding
    config.recoverCov = parsed.recover_cov
    config.estimateParameters['intrinsics'] = not parsed.lock_intrinsics
    config.estimateParameters['distortion'] = not parsed.lock_distortion
    config.estimateParameters['timeOffset'] = parsed.time_calibration and (parsed.imu_yaml is not None)
    config.chain_yaml = parsed.chain_yaml
    config.saveSamplePoses = parsed.saveSamplePoses
    config.reprojectFrameIndex = parsed.reprojectFrameIndex

    ######
    ## Calibrate
    calibrator = rscc.RsCalibrator()
    imuDescription = rscc.ImuDataDescription([parsed.bagfile], parsed.bag_from_to,
                                             parsed.perform_synchronization, parsed.constant_bias)
    calibrator.loadImu(parsed.imu_yaml, parsed.imu_model, imuDescription)
    tic = time.time()
    calibrator.calibrate(cameraGeometry, observations, config)
    toc = time.time()
    calibrate_time = toc - tic
    print("Timing (sec): Extraction observations {:.4f}, rolling shutter calibration {:.4f}".format(
        extract_time, calibrate_time))

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        sm.logError("Exception: {0}".format(e))
        sys.exit(-1)

